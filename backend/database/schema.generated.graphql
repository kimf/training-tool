# THIS FILE HAS BEEN AUTO-GENERATED BY THE "GRAPHCOOL DEPLOY"
# DO NOT EDIT THIS FILE DIRECTLY

#
# Model Types
#

type Measurement implements Node {
  id: ID!
  date: DateTime!
  weight: Float!
  waist: Float!
  thigh: Float!
  hips: Float!
}

type Sport implements Node {
  id: ID!
  name: String!
}

type Workout implements Node {
  id: ID!
  plannedDate: DateTime!
  plannedKm: Float
  plannedMinutes: Float!
  plannedType: String!
  plannedSport: String!
  plannedInformation: String
  activityData: Json
  actualDate: DateTime
  actualKm: Float
  actualMinutes: Float
  actualType: String
  actualSport: String
}

type WorkoutTemplate implements Node {
  id: ID!
  type: String!
  sport: String!
  time: Float!
  km: Float
  notes: String
  workout: Json
}

type WorkoutType implements Node {
  id: ID!
  name: String!
}


#
# Other Types
#

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Json

scalar Long

type MeasurementConnection {
  pageInfo: PageInfo!
  edges: [MeasurementEdge]!
}

input MeasurementCreateInput {
  date: DateTime!
  weight: Float!
  waist: Float!
  thigh: Float!
  hips: Float!
}

type MeasurementEdge {
  node: Measurement!
  cursor: String!
}

enum MeasurementOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  weight_ASC
  weight_DESC
  waist_ASC
  waist_DESC
  thigh_ASC
  thigh_DESC
  hips_ASC
  hips_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type MeasurementPreviousValues {
  id: ID!
  date: DateTime!
  weight: Float!
  waist: Float!
  thigh: Float!
  hips: Float!
}

type MeasurementSubscriptionPayload {
  mutation: MutationType!
  node: Measurement
  updatedFields: [String!]
  previousValues: MeasurementPreviousValues
}

input MeasurementSubscriptionWhereInput {
  AND: [MeasurementSubscriptionWhereInput!]
  OR: [MeasurementSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MeasurementWhereInput
}

input MeasurementUpdateInput {
  date: DateTime
  weight: Float
  waist: Float
  thigh: Float
  hips: Float
}

input MeasurementWhereInput {
  AND: [MeasurementWhereInput!]
  OR: [MeasurementWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  weight: Float
  weight_not: Float
  weight_in: [Float!]
  weight_not_in: [Float!]
  weight_lt: Float
  weight_lte: Float
  weight_gt: Float
  weight_gte: Float
  waist: Float
  waist_not: Float
  waist_in: [Float!]
  waist_not_in: [Float!]
  waist_lt: Float
  waist_lte: Float
  waist_gt: Float
  waist_gte: Float
  thigh: Float
  thigh_not: Float
  thigh_in: [Float!]
  thigh_not_in: [Float!]
  thigh_lt: Float
  thigh_lte: Float
  thigh_gt: Float
  thigh_gte: Float
  hips: Float
  hips_not: Float
  hips_in: [Float!]
  hips_not_in: [Float!]
  hips_lt: Float
  hips_lte: Float
  hips_gt: Float
  hips_gte: Float
}

input MeasurementWhereUniqueInput {
  id: ID
}

type Mutation {
  createWorkout(data: WorkoutCreateInput!): Workout!
  createMeasurement(data: MeasurementCreateInput!): Measurement!
  createWorkoutTemplate(data: WorkoutTemplateCreateInput!): WorkoutTemplate!
  createWorkoutType(data: WorkoutTypeCreateInput!): WorkoutType!
  createSport(data: SportCreateInput!): Sport!
  updateWorkout(data: WorkoutUpdateInput!, where: WorkoutWhereUniqueInput!): Workout
  updateMeasurement(data: MeasurementUpdateInput!, where: MeasurementWhereUniqueInput!): Measurement
  updateWorkoutTemplate(data: WorkoutTemplateUpdateInput!, where: WorkoutTemplateWhereUniqueInput!): WorkoutTemplate
  updateWorkoutType(data: WorkoutTypeUpdateInput!, where: WorkoutTypeWhereUniqueInput!): WorkoutType
  updateSport(data: SportUpdateInput!, where: SportWhereUniqueInput!): Sport
  deleteWorkout(where: WorkoutWhereUniqueInput!): Workout
  deleteMeasurement(where: MeasurementWhereUniqueInput!): Measurement
  deleteWorkoutTemplate(where: WorkoutTemplateWhereUniqueInput!): WorkoutTemplate
  deleteWorkoutType(where: WorkoutTypeWhereUniqueInput!): WorkoutType
  deleteSport(where: SportWhereUniqueInput!): Sport
  upsertWorkout(where: WorkoutWhereUniqueInput!, create: WorkoutCreateInput!, update: WorkoutUpdateInput!): Workout!
  upsertMeasurement(where: MeasurementWhereUniqueInput!, create: MeasurementCreateInput!, update: MeasurementUpdateInput!): Measurement!
  upsertWorkoutTemplate(where: WorkoutTemplateWhereUniqueInput!, create: WorkoutTemplateCreateInput!, update: WorkoutTemplateUpdateInput!): WorkoutTemplate!
  upsertWorkoutType(where: WorkoutTypeWhereUniqueInput!, create: WorkoutTypeCreateInput!, update: WorkoutTypeUpdateInput!): WorkoutType!
  upsertSport(where: SportWhereUniqueInput!, create: SportCreateInput!, update: SportUpdateInput!): Sport!
  updateManyWorkouts(data: WorkoutUpdateInput!, where: WorkoutWhereInput!): BatchPayload!
  updateManyMeasurements(data: MeasurementUpdateInput!, where: MeasurementWhereInput!): BatchPayload!
  updateManyWorkoutTemplates(data: WorkoutTemplateUpdateInput!, where: WorkoutTemplateWhereInput!): BatchPayload!
  updateManyWorkoutTypes(data: WorkoutTypeUpdateInput!, where: WorkoutTypeWhereInput!): BatchPayload!
  updateManySports(data: SportUpdateInput!, where: SportWhereInput!): BatchPayload!
  deleteManyWorkouts(where: WorkoutWhereInput!): BatchPayload!
  deleteManyMeasurements(where: MeasurementWhereInput!): BatchPayload!
  deleteManyWorkoutTemplates(where: WorkoutTemplateWhereInput!): BatchPayload!
  deleteManyWorkoutTypes(where: WorkoutTypeWhereInput!): BatchPayload!
  deleteManySports(where: SportWhereInput!): BatchPayload!
  resetData: Boolean
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  workouts(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workout]!
  measurements(where: MeasurementWhereInput, orderBy: MeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Measurement]!
  workoutTemplates(where: WorkoutTemplateWhereInput, orderBy: WorkoutTemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkoutTemplate]!
  workoutTypes(where: WorkoutTypeWhereInput, orderBy: WorkoutTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkoutType]!
  sports(where: SportWhereInput, orderBy: SportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sport]!
  workout(where: WorkoutWhereUniqueInput!): Workout
  measurement(where: MeasurementWhereUniqueInput!): Measurement
  workoutTemplate(where: WorkoutTemplateWhereUniqueInput!): WorkoutTemplate
  workoutType(where: WorkoutTypeWhereUniqueInput!): WorkoutType
  sport(where: SportWhereUniqueInput!): Sport
  workoutsConnection(where: WorkoutWhereInput, orderBy: WorkoutOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutConnection!
  measurementsConnection(where: MeasurementWhereInput, orderBy: MeasurementOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MeasurementConnection!
  workoutTemplatesConnection(where: WorkoutTemplateWhereInput, orderBy: WorkoutTemplateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutTemplateConnection!
  workoutTypesConnection(where: WorkoutTypeWhereInput, orderBy: WorkoutTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkoutTypeConnection!
  sportsConnection(where: SportWhereInput, orderBy: SportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SportConnection!
  node(id: ID!): Node
}

type SportConnection {
  pageInfo: PageInfo!
  edges: [SportEdge]!
}

input SportCreateInput {
  name: String!
}

type SportEdge {
  node: Sport!
  cursor: String!
}

enum SportOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type SportPreviousValues {
  id: ID!
  name: String!
}

type SportSubscriptionPayload {
  mutation: MutationType!
  node: Sport
  updatedFields: [String!]
  previousValues: SportPreviousValues
}

input SportSubscriptionWhereInput {
  AND: [SportSubscriptionWhereInput!]
  OR: [SportSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SportWhereInput
}

input SportUpdateInput {
  name: String
}

input SportWhereInput {
  AND: [SportWhereInput!]
  OR: [SportWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
}

input SportWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  workout(where: WorkoutSubscriptionWhereInput): WorkoutSubscriptionPayload
  measurement(where: MeasurementSubscriptionWhereInput): MeasurementSubscriptionPayload
  workoutTemplate(where: WorkoutTemplateSubscriptionWhereInput): WorkoutTemplateSubscriptionPayload
  workoutType(where: WorkoutTypeSubscriptionWhereInput): WorkoutTypeSubscriptionPayload
  sport(where: SportSubscriptionWhereInput): SportSubscriptionPayload
}

type WorkoutConnection {
  pageInfo: PageInfo!
  edges: [WorkoutEdge]!
}

input WorkoutCreateInput {
  plannedDate: DateTime!
  plannedKm: Float
  plannedMinutes: Float!
  plannedType: String!
  plannedSport: String!
  plannedInformation: String
  activityData: Json
  actualDate: DateTime
  actualKm: Float
  actualMinutes: Float
  actualType: String
  actualSport: String
}

type WorkoutEdge {
  node: Workout!
  cursor: String!
}

enum WorkoutOrderByInput {
  id_ASC
  id_DESC
  plannedDate_ASC
  plannedDate_DESC
  plannedKm_ASC
  plannedKm_DESC
  plannedMinutes_ASC
  plannedMinutes_DESC
  plannedType_ASC
  plannedType_DESC
  plannedSport_ASC
  plannedSport_DESC
  plannedInformation_ASC
  plannedInformation_DESC
  activityData_ASC
  activityData_DESC
  actualDate_ASC
  actualDate_DESC
  actualKm_ASC
  actualKm_DESC
  actualMinutes_ASC
  actualMinutes_DESC
  actualType_ASC
  actualType_DESC
  actualSport_ASC
  actualSport_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type WorkoutPreviousValues {
  id: ID!
  plannedDate: DateTime!
  plannedKm: Float
  plannedMinutes: Float!
  plannedType: String!
  plannedSport: String!
  plannedInformation: String
  activityData: Json
  actualDate: DateTime
  actualKm: Float
  actualMinutes: Float
  actualType: String
  actualSport: String
}

type WorkoutSubscriptionPayload {
  mutation: MutationType!
  node: Workout
  updatedFields: [String!]
  previousValues: WorkoutPreviousValues
}

input WorkoutSubscriptionWhereInput {
  AND: [WorkoutSubscriptionWhereInput!]
  OR: [WorkoutSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutWhereInput
}

type WorkoutTemplateConnection {
  pageInfo: PageInfo!
  edges: [WorkoutTemplateEdge]!
}

input WorkoutTemplateCreateInput {
  type: String!
  sport: String!
  time: Float!
  km: Float
  notes: String
  workout: Json
}

type WorkoutTemplateEdge {
  node: WorkoutTemplate!
  cursor: String!
}

enum WorkoutTemplateOrderByInput {
  id_ASC
  id_DESC
  type_ASC
  type_DESC
  sport_ASC
  sport_DESC
  time_ASC
  time_DESC
  km_ASC
  km_DESC
  notes_ASC
  notes_DESC
  workout_ASC
  workout_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type WorkoutTemplatePreviousValues {
  id: ID!
  type: String!
  sport: String!
  time: Float!
  km: Float
  notes: String
  workout: Json
}

type WorkoutTemplateSubscriptionPayload {
  mutation: MutationType!
  node: WorkoutTemplate
  updatedFields: [String!]
  previousValues: WorkoutTemplatePreviousValues
}

input WorkoutTemplateSubscriptionWhereInput {
  AND: [WorkoutTemplateSubscriptionWhereInput!]
  OR: [WorkoutTemplateSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutTemplateWhereInput
}

input WorkoutTemplateUpdateInput {
  type: String
  sport: String
  time: Float
  km: Float
  notes: String
  workout: Json
}

input WorkoutTemplateWhereInput {
  AND: [WorkoutTemplateWhereInput!]
  OR: [WorkoutTemplateWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  sport: String
  sport_not: String
  sport_in: [String!]
  sport_not_in: [String!]
  sport_lt: String
  sport_lte: String
  sport_gt: String
  sport_gte: String
  sport_contains: String
  sport_not_contains: String
  sport_starts_with: String
  sport_not_starts_with: String
  sport_ends_with: String
  sport_not_ends_with: String
  time: Float
  time_not: Float
  time_in: [Float!]
  time_not_in: [Float!]
  time_lt: Float
  time_lte: Float
  time_gt: Float
  time_gte: Float
  km: Float
  km_not: Float
  km_in: [Float!]
  km_not_in: [Float!]
  km_lt: Float
  km_lte: Float
  km_gt: Float
  km_gte: Float
  notes: String
  notes_not: String
  notes_in: [String!]
  notes_not_in: [String!]
  notes_lt: String
  notes_lte: String
  notes_gt: String
  notes_gte: String
  notes_contains: String
  notes_not_contains: String
  notes_starts_with: String
  notes_not_starts_with: String
  notes_ends_with: String
  notes_not_ends_with: String
}

input WorkoutTemplateWhereUniqueInput {
  id: ID
}

type WorkoutTypeConnection {
  pageInfo: PageInfo!
  edges: [WorkoutTypeEdge]!
}

input WorkoutTypeCreateInput {
  name: String!
}

type WorkoutTypeEdge {
  node: WorkoutType!
  cursor: String!
}

enum WorkoutTypeOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  updatedAt_ASC
  updatedAt_DESC
  createdAt_ASC
  createdAt_DESC
}

type WorkoutTypePreviousValues {
  id: ID!
  name: String!
}

type WorkoutTypeSubscriptionPayload {
  mutation: MutationType!
  node: WorkoutType
  updatedFields: [String!]
  previousValues: WorkoutTypePreviousValues
}

input WorkoutTypeSubscriptionWhereInput {
  AND: [WorkoutTypeSubscriptionWhereInput!]
  OR: [WorkoutTypeSubscriptionWhereInput!]
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkoutTypeWhereInput
}

input WorkoutTypeUpdateInput {
  name: String
}

input WorkoutTypeWhereInput {
  AND: [WorkoutTypeWhereInput!]
  OR: [WorkoutTypeWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
}

input WorkoutTypeWhereUniqueInput {
  id: ID
  name: String
}

input WorkoutUpdateInput {
  plannedDate: DateTime
  plannedKm: Float
  plannedMinutes: Float
  plannedType: String
  plannedSport: String
  plannedInformation: String
  activityData: Json
  actualDate: DateTime
  actualKm: Float
  actualMinutes: Float
  actualType: String
  actualSport: String
}

input WorkoutWhereInput {
  AND: [WorkoutWhereInput!]
  OR: [WorkoutWhereInput!]
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  plannedDate: DateTime
  plannedDate_not: DateTime
  plannedDate_in: [DateTime!]
  plannedDate_not_in: [DateTime!]
  plannedDate_lt: DateTime
  plannedDate_lte: DateTime
  plannedDate_gt: DateTime
  plannedDate_gte: DateTime
  plannedKm: Float
  plannedKm_not: Float
  plannedKm_in: [Float!]
  plannedKm_not_in: [Float!]
  plannedKm_lt: Float
  plannedKm_lte: Float
  plannedKm_gt: Float
  plannedKm_gte: Float
  plannedMinutes: Float
  plannedMinutes_not: Float
  plannedMinutes_in: [Float!]
  plannedMinutes_not_in: [Float!]
  plannedMinutes_lt: Float
  plannedMinutes_lte: Float
  plannedMinutes_gt: Float
  plannedMinutes_gte: Float
  plannedType: String
  plannedType_not: String
  plannedType_in: [String!]
  plannedType_not_in: [String!]
  plannedType_lt: String
  plannedType_lte: String
  plannedType_gt: String
  plannedType_gte: String
  plannedType_contains: String
  plannedType_not_contains: String
  plannedType_starts_with: String
  plannedType_not_starts_with: String
  plannedType_ends_with: String
  plannedType_not_ends_with: String
  plannedSport: String
  plannedSport_not: String
  plannedSport_in: [String!]
  plannedSport_not_in: [String!]
  plannedSport_lt: String
  plannedSport_lte: String
  plannedSport_gt: String
  plannedSport_gte: String
  plannedSport_contains: String
  plannedSport_not_contains: String
  plannedSport_starts_with: String
  plannedSport_not_starts_with: String
  plannedSport_ends_with: String
  plannedSport_not_ends_with: String
  plannedInformation: String
  plannedInformation_not: String
  plannedInformation_in: [String!]
  plannedInformation_not_in: [String!]
  plannedInformation_lt: String
  plannedInformation_lte: String
  plannedInformation_gt: String
  plannedInformation_gte: String
  plannedInformation_contains: String
  plannedInformation_not_contains: String
  plannedInformation_starts_with: String
  plannedInformation_not_starts_with: String
  plannedInformation_ends_with: String
  plannedInformation_not_ends_with: String
  actualDate: DateTime
  actualDate_not: DateTime
  actualDate_in: [DateTime!]
  actualDate_not_in: [DateTime!]
  actualDate_lt: DateTime
  actualDate_lte: DateTime
  actualDate_gt: DateTime
  actualDate_gte: DateTime
  actualKm: Float
  actualKm_not: Float
  actualKm_in: [Float!]
  actualKm_not_in: [Float!]
  actualKm_lt: Float
  actualKm_lte: Float
  actualKm_gt: Float
  actualKm_gte: Float
  actualMinutes: Float
  actualMinutes_not: Float
  actualMinutes_in: [Float!]
  actualMinutes_not_in: [Float!]
  actualMinutes_lt: Float
  actualMinutes_lte: Float
  actualMinutes_gt: Float
  actualMinutes_gte: Float
  actualType: String
  actualType_not: String
  actualType_in: [String!]
  actualType_not_in: [String!]
  actualType_lt: String
  actualType_lte: String
  actualType_gt: String
  actualType_gte: String
  actualType_contains: String
  actualType_not_contains: String
  actualType_starts_with: String
  actualType_not_starts_with: String
  actualType_ends_with: String
  actualType_not_ends_with: String
  actualSport: String
  actualSport_not: String
  actualSport_in: [String!]
  actualSport_not_in: [String!]
  actualSport_lt: String
  actualSport_lte: String
  actualSport_gt: String
  actualSport_gte: String
  actualSport_contains: String
  actualSport_not_contains: String
  actualSport_starts_with: String
  actualSport_not_starts_with: String
  actualSport_ends_with: String
  actualSport_not_ends_with: String
}

input WorkoutWhereUniqueInput {
  id: ID
}
